<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  

  

  

  

  

  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="面试,源码分析,异步消息," />





  <link rel="alternate" href="/atom.xml" title="wy521angel的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="Looper、Handler与Message">
<meta property="og:type" content="article">
<meta property="og:title" content="Android异步消息处理机制详解">
<meta property="og:url" content="http://yoursite.com/2017/08/10/IT/Android/%E7%BA%BF%E7%A8%8B/Android%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="wy521angel的博客">
<meta property="og:description" content="Looper、Handler与Message">
<meta property="og:image" content="https://github.com/wy521angel/MarkdowmPhotos/blob/master/IT/Android/%E7%BA%BF%E7%A8%8B/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/Handler%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true">
<meta property="og:image" content="https://raw.githubusercontent.com/wy521angel/MarkdowmPhotos/64f6f50d6d67050100760686fe5c0ddcfbf830c7/IT/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wy521angel/MarkdowmPhotos/4f889a4c7963a529339bb0e9276f1ae81be2172e/IT/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/Looper%20%2C%20Handler%20%2C%20Message%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png">
<meta property="article:published_time" content="2017-08-09T16:00:00.000Z">
<meta property="article:modified_time" content="2020-02-27T15:56:46.000Z">
<meta property="article:author" content="wy521angel">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="源码分析">
<meta property="article:tag" content="异步消息">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/wy521angel/MarkdowmPhotos/blob/master/IT/Android/%E7%BA%BF%E7%A8%8B/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/Handler%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/08/10/IT/Android/线程/Android异步消息处理机制详解/"/>





  <title>Android异步消息处理机制详解 | wy521angel的博客</title>
  














<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wy521angel的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一个从事IT工作的伪文艺青年</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-photo">
          <a href="/photo/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-camera"></i> <br />
            
            相册
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/10/IT/Android/%E7%BA%BF%E7%A8%8B/Android%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wy521angel">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myavatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wy521angel的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android异步消息处理机制详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-10T00:00:00+08:00">
                2017-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index">
                    <span itemprop="name">IT</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT/Android/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">线程</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT/Android/%E7%BA%BF%E7%A8%8B/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF/" itemprop="url" rel="index">
                    <span itemprop="name">异步消息</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/10/IT/Android/%E7%BA%BF%E7%A8%8B/Android%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" class="leancloud_visitors" data-flag-title="Android异步消息处理机制详解">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          
              <div class="post-description">
                  Looper、Handler与Message
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&#160; &#160; &#160; &#160;从开发的角度来说，Handler 是 Android 消息机制的上层接口，这使得在开发过程中只需要和 Handler 交互即可。Handler 的使用过程很简单，通过它可以轻松地将一个任务切换到 Handler 所在的线程中去执行。很多人认为 Handler 的作用是更新 UI，这的确没错，但是更新 UI 仅仅是 Handler 的一个特殊的使用场景。具体来说是这样的：有时候需要在子线程中进行耗时的 I/O 操作，可能是读取文件或者访问网络等，当耗时操作完成以后可能需要在 UI 上做一些改变，由于 Android 开发规范的限制，我们并不能在子线程中访问 UI 控件，否则就会触发程序异常，这个时候通过 Handler 就可以将更新 UI 的操作切换到主线程中执行。因此，本质上来说，Handler 并不是专门用于更新 UI 的，它只是常被开发者用来更新 UI。</p>
<p>&#160; &#160; &#160; &#160;Android 的消息机制主要是指 Handler 的运行机制，Handler 的运行需要底层的 MessageQueue 和 Looper 的支撑。MessageQueue 的中文翻译是消息队列，顾名思义，它的内部存储了一组消息，以队列的形式对外提供插入和删除的工作。虽然叫消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表。Looper 的中文翻译为循环，在这里可以理解为消息循环。由于 MessageQueue 只是一个消息的存储单元，它不能去处理消息，而 Looper 就填补了这个功能，它负责的就是创建一个 MessageQueue，每个线程只能有一个 Looper，Looper 会以无限循环的形式从 MessageQueue 中读取消息，如果有新消息的话就把消息发送给 Handler 进行处理，而消息的创建者和处理者就是一个或多个 Handler，否则就一直等待着。Looper 中还有一个特殊的概念，那就是 ThreadLocal，ThreadLocal 并不是线程，它的作用是可以在每个线程中存储数据。Handler 创建的时候会采用当前线程的 Looper 来构造消息循环系统，那么 Handler 内部如何获取到当前线程的 Looper 呢？这就要使用 ThreadLocal 了，ThreadLocal 可以在不同的线程中互不干扰地存储并提供数据，通过 ThreadLocal 可以轻松获取每个线程的 Looper。当然需要注意的是，线程是默认没有 Looper 的，如果需要使用 Handler 就必须为线程创建 Looper。我们经常提到的主线程，也叫 UI 线程，它就是 ActivityThread，ActivityThread 被创建时就会初始化 Looper，这也是在主线程中默认可以使用 Handler 的原因。</p>
<h1 id="Looper的两个重要方法"><a href="#Looper的两个重要方法" class="headerlink" title="Looper的两个重要方法"></a>Looper的两个重要方法</h1><p>&#160; &#160; &#160; &#160;Looper 在 Android 的消息机制中扮演着消息循环的角色，具体来说就是它会不停地从 MessageQueue 中查看是否有新消息，如果有新消息就会立刻处理，否则就一直阻塞在那里。</p>
<h2 id="Looper-prepare"><a href="#Looper-prepare" class="headerlink" title="Looper.prepare()"></a>Looper.prepare()</h2><p>&#160; &#160; &#160; &#160;首先来看一下如何创建 Handler 对象。我们尝试在程序中创建两个 Handler 对象，一个在主线程中创建，一个在子线程中创建，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler handler1;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler handler2;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">        setContentView(R.layout.activity_main);  </span><br><span class="line">        handler1 = <span class="keyword">new</span> Handler();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                handler2 = <span class="keyword">new</span> Handler();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;).start();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;运行程序会发现在子线程中创建的 Handler 是会导致程序崩溃的，提示的错误信息为 Can’t create handler inside thread that has not called Looper.prepare()。说不能在没有调用 Looper.prepare() 的线程中创建 Handler，那我们尝试在子线程中先调用一下 Looper.prepare()，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        Looper.prepare();  </span><br><span class="line">        handler2 = <span class="keyword">new</span> Handler();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;这样就不会崩溃了，看下 Handler 的源码，Handler 的无参构造函数如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ...</span><br><span class="line">    mLooper = Looper.myLooper();  </span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(  </span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;可以看到调用了 Looper.myLooper() 方法获取了一个 Looper 对象，如果 Looper 对象为空，则会抛出一个运行时异常，提示的错误正是 Can’t create handler inside thread that has not called Looper.prepare()。那什么时候 Looper 对象才可能为空呢？看看 Looper.myLooper() 中的代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (Looper)sThreadLocal.get();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;这个方法非常简单，就是从 sThreadLocal 对象中取出 Looper。如果 sThreadLocal 中有 Looper 存在就返回 Looper，如果没有 Looper 存在自然就返回空了。</p>
<p>&#160; &#160; &#160; &#160;对于 Looper 主要是 prepare() 和 loop() 两个方法。在 Looper.prepare() 方法中给 sThreadLocal 设置 Looper，看下它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(<span class="keyword">true</span>));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;可以看到，首先判断 sThreadLocal 中是否已经存在 Looper 了，如果还没有则创建一个新的 Looper 设置进去。sThreadLocal 是一个 <a href="https://wy521angel.github.io/2020/01/21/IT/Android/线程/ThreadLocal的工作原理/" target="_blank" rel="noopener">ThreadLocal</a> 对象，可以在一个线程中存储变量。在第5行，将一个 Looper 的实例放入了 ThreadLocal，并且2-4行判断了 sThreadLocal 是否为 null，否则抛出异常。也就完全解释了为什么我们要先调用 Looper.prepare() 方法，才能创建 Handler 对象。同时也可以看出 Looper.prepare() 方法不能被调用两次，同时也保证了一个线程中只有一个 Looper 实例。</p>
<p>&#160; &#160; &#160; &#160;主线程中的 Handler 也没有调用 Looper.prepare() 方法，为什么没有崩溃？这是由于在程序启动的时候，系统已经帮我们自动调用了 Looper.prepare() 方法。查看 ActivityThread 中的 main() 方法，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    SamplingProfilerIntegration.start();  </span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);  </span><br><span class="line">    Environment.initForCurrentUser();  </span><br><span class="line">    EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());  </span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);  </span><br><span class="line">    Looper.prepareMainLooper();  </span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();  </span><br><span class="line">    thread.attach(<span class="keyword">false</span>);  </span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        sMainThreadHandler = thread.getHandler();  </span><br><span class="line">    &#125;  </span><br><span class="line">    AsyncTask.init();  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;  </span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span> LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">    Looper.loop();  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;可以看到，在第7行调用了 Looper.prepareMainLooper() 方法，而这个方法又会再去调用 Looper.prepare() 方法，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    prepare();  </span><br><span class="line">    setMainLooper(myLooper());  </span><br><span class="line">    <span class="keyword">if</span> (Process.supportsProcesses()) &#123;  </span><br><span class="line">        myLooper().mQueue.mQuitAllowed = <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;因此应用程序的主线程中会始终存在一个 Looper 对象，从而不需要再手动去调用 Looper.prepare() 方法了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在主线程中可以直接创建 Handler 对象，而在子线程中需要先调用 Looper.prepare() 才能创建 Handler 对象。</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;由上面可知 Looper 除了 prepare 方法外，还提供了 prepareMainLooper 方法，这个方法主要是给主线程也就是 ActivityThread 创建 Looper 使用的，其本质也是通过 prepare 方法来实现的。由于主线程的 Looper 比较特殊，所以 Looper 提供了一个 getMainLooper 方法，通过它可以在任何地方获取到主线程的 Looper。Looper 也是可以退出的，Looper 提供了 quit 和 quitSafely 来退出一个 Looper，二者的区别是：quit 会直接退出 Looper，而 quitSafely 只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全地退出。Looper 退出后，通过 Handler 发送的消息会失败，这个时候 Handler 的 send 方法会返回 false。在子线程中，如果手动为其创建了 Looper，那么在所有的事情完成以后应该调用 quit 方法来终止消息循环，否则这个子线程就会一直处于等待的状态，而如果退出Looper以后，这个线程就会立刻终止，因此建议不需要的时候终止 Looper。</p>
<h2 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a>Looper.loop()</h2><p>&#160; &#160; &#160; &#160;只有调用了 loop 后，消息循环系统才会真正地起作用，它的实现如下所示。下面先看 Looper 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;  </span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);  </span><br><span class="line">        mRun = <span class="keyword">true</span>;  </span><br><span class="line">        mThread = Thread.currentThread();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;在构造方法中，创建了一个 MessageQueue，一个 Looper 也对应一个 MessageQueue。然后看 loop() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();  </span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,  </span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.  </span></span><br><span class="line">        Binder.clearCallingIdentity();  </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block  </span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.  </span></span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger  </span></span><br><span class="line">            Printer logging = me.mLogging;  </span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +  </span><br><span class="line">                        msg.callback + <span class="string">": "</span> + msg.what);  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            msg.target.dispatchMessage(msg);  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the  </span></span><br><span class="line">            <span class="comment">// identity of the thread wasn't corrupted.  </span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();  </span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;  </span><br><span class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span>  </span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span>  </span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span>  </span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span>  </span><br><span class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            msg.recycle();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;第2行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;方法直接返回了 sThreadLocal 存储的 Looper 实例，如果 me 为 null 则抛出异常，也就是说 loop 方法必须在 prepare 方法之后运行。</p>
<p>&#160; &#160; &#160; &#160;第6行：拿到该 looper 实例中的 mQueue（消息队列）。</p>
<p>&#160; &#160; &#160; &#160;13到45行：就进入了我们所说的无限循环。</p>
<p>&#160; &#160; &#160; &#160;14行：取出一条消息，这个 next() 方法就是获取消息的方法，它的简单逻辑就是如果当前 MessageQueue 中存在 mMessages (即待处理消息)，就取出这个消息，然后让下一条消息成为 mMessages，如果没有消息则阻塞，一直等到有新的消息进来。</p>
<p>&#160; &#160; &#160; &#160;27行：调用 msg.target.dispatchMessage(msg) 把消息交给 msg 的 target 的 dispatchMessage 方法去处理。Msg 的 target 其实就是 handler 对象，下面会进行分析。</p>
<p>&#160; &#160; &#160; &#160;44行：释放消息占据的资源。</p>
<p>&#160; &#160; &#160; &#160;Looper 主要作用：</p>
<ol>
<li>与当前线程绑定，保证一个线程只会有一个 Looper 实例，同时一个 Looper 实例也只有一个 MessageQueue。  </li>
<li>loop() 方法，不断从 MessageQueue 中去取消息，交给消息的 target 属性的 dispatchMessage 去处理。</li>
</ol>
<p>&#160; &#160; &#160; &#160;现在异步消息处理线程已经有了消息队列（MessageQueue），也可以在无限循环体中取出消息，现在缺的就是发送消息的对象了，于是乎Handler登场了。</p>
<h1 id="Handler-消息发送与-MessageQueue"><a href="#Handler-消息发送与-MessageQueue" class="headerlink" title="Handler 消息发送与 MessageQueue"></a>Handler 消息发送与 MessageQueue</h1><p>&#160; &#160; &#160; &#160;Handler 的工作主要包含消息的发送和接收过程。消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现，post 的一系列方法最终是通过 send 的一系列方法来实现的。在 Looper.prepare() 一节中已经介绍了 Handler 的创建，使用 Handler 之前，我们都是初始化一个实例，比如用于更新 UI 线程，会在声明的时候直接初始化，或者在 onCreate 中初始化 Handler 实例。发送消息的流程已经非常熟悉：new 出一个 Message 对象，然后可以使用 setData() 方法或 arg 参数等方式为消息携带一些数据，再借助 Handler 将消息发送出去就可以了，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        Message message = <span class="keyword">new</span> Message();  </span><br><span class="line">        message.arg1 = <span class="number">1</span>;  </span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();  </span><br><span class="line">        bundle.putString(<span class="string">"data"</span>, <span class="string">"data"</span>);  </span><br><span class="line">        message.setData(bundle);  </span><br><span class="line">        handler.sendMessage(message);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;这里 Handler 到底把 Message 发送到哪里去了呢？为什么之后又可以在 Handler 的 handleMessage() 方法中重新得到这条 Message 呢？Handler 中提供了很多个发送消息的方法，其中除了 sendMessageAtFrontOfQueue() 方法之外，其它的发送消息方法最终都会辗转调用到 sendMessageAtTime() 方法中。我们再看 Handler 的构造方法，看其如何与 MessageQueue 联系上的，它在子线程中发送的消息（一般发送消息都在非 UI 线程）怎么发送到 MessageQueue 中的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;  </span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();  </span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;  </span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;  </span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +  </span><br><span class="line">                    klass.getCanonicalName());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();  </span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(  </span><br><span class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        mQueue = mLooper.mQueue;  </span><br><span class="line">        mCallback = callback;  </span><br><span class="line">        mAsynchronous = async;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;11行：通过Looper.myLooper()获取了当前线程保存的 Looper 实例，然后在16行又获取了这个 Looper 实例中保存的 MessageQueue（消息队列），这样就保证了 handler 的实例与 Looper 实例中 MessageQueue 关联上了。</p>
<p>&#160; &#160; &#160; &#160;另外，Handler 还有一个特殊的构造方法，那就是通过一个特定的 Looper 来构造 Handler，它的实现如下所示。通过这个构造方法可以实现一些特殊的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;然后看最常用的 sendMessage 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;  </span><br><span class="line">     Message msg = Message.obtain();  </span><br><span class="line">     msg.what = what;  </span><br><span class="line">     <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">          delayMillis = <span class="number">0</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;  </span><br><span class="line">       MessageQueue queue = mQueue;  </span><br><span class="line">       <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;  </span><br><span class="line">           RuntimeException e = <span class="keyword">new</span> RuntimeException(  </span><br><span class="line">                   <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);  </span><br><span class="line">           Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);  </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;sendMessageAtTime() 方法接收两个参数，其中 msg 参数就是我们发送的 Message 对象，而 uptimeMillis 参数则表示发送消息的时间，它的值等于自系统开机到当前时间的毫秒数再加上延迟时间，如果你调用的不是 sendMessageDelayed() 方法，延迟时间就为0。enqueueMessage()方法毫无疑问就是入队的方法了，我们来看下这个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;  </span><br><span class="line">       msg.target = <span class="keyword">this</span>;  </span><br><span class="line">       <span class="keyword">if</span> (mAsynchronous) &#123;  </span><br><span class="line">           msg.setAsynchronous(<span class="keyword">true</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;enqueueMessage 中首先为 msg.target 赋值为 this，（如果还记得 Looper 的 loop 方法会取出每个 msg 然后交给 msg.target.dispatchMessage(msg) 去处理消息），也就是把当前的 handler 作为 msg 的 target 属性。最终会调用 queue 的 enqueueMessage 的方法，也就是说 handler 发出的消息，最终会保存到消息队列中去。</p>
<p>&#160; &#160; &#160; &#160;queue.enqueueMessage 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (msg.when != <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(msg + <span class="string">" This message is already in use."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span> &amp;&amp; !mQuitAllowed) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread not allowed to quit"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (mQuiting) &#123;  </span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);  </span><br><span class="line">            Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            mQuiting = <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        msg.when = when;  </span><br><span class="line">        Message p = mMessages;  </span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;  </span><br><span class="line">            msg.next = p;  </span><br><span class="line">            mMessages = msg;  </span><br><span class="line">            <span class="keyword">this</span>.notify();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            Message prev = <span class="keyword">null</span>;  </span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;  </span><br><span class="line">                prev = p;  </span><br><span class="line">                p = p.next;  </span><br><span class="line">            &#125;  </span><br><span class="line">            msg.next = prev.next;  </span><br><span class="line">            prev.next = msg;  </span><br><span class="line">            <span class="keyword">this</span>.notify();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;消息队列在 Android 中指的就是 MessageQueue，MessageQueue 主要包含两个操作：插入和读取。读取操作本身会伴随着删除操作，插入和读取对应的方法分别为 enqueueMessage 和 next，其中 enqueueMessage 的作用是往消息队列中插入一条消息，而 next 的作用是从消息队列中取出一条消息并将其从消息队列中移除。尽管 MessageQueue 叫消息队列，但是它的内部实现并不是用的队列，实际上它是通过一个单链表的数据结构来维护消息列表，单链表在插入和删除上比较有优势。</p>
<p>&#160; &#160; &#160; &#160;MessageQueue 并没有使用一个集合把所有的消息都保存起来，它只使用了一个 mMessages 对象表示当前待处理的消息。然后观察上面的代码的16~31行就可以看出，所谓的入队其实就是将所有的消息按时间来进行排序，这个时间就是刚才介绍的 uptimeMillis 参数。具体的操作方法就根据时间的顺序调用 msg.next，从而为每一个消息指定它的下一个消息是什么。当然如果是通过 sendMessageAtFrontOfQueue() 方法来发送消息的，它也会调用 enqueueMessage() 来让消息入队，只不过时间为0，这时会把 mMessages 赋值为新入队的这条消息，然后将这条消息的 next 指定为刚才的 mMessages，这样也就完成了添加消息到链表头部的操作。</p>
<p>&#160; &#160; &#160; &#160;Handler 发送消息的过程仅仅是向消息队列中插入了一条消息。Looper 会调用 prepare() 和 loop() 方法，在当前执行的线程中保存一个 Looper 实例，这个实例会保存一个 MessageQueue 对象，然后当前线程进入一个无限循环中去，不断从 MessageQueue 中读取 Handler 发来的消息（MessageQueue 的 next 方法返回这条消息给 Looper）。最终消息由 Looper 交由 Handler 处理，即 Handler 的 dispatchMessage 方法会被调用，这时 Handler 就进入了处理消息的阶段。下面我们去看一看这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            handleCallback(msg);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;  </span><br><span class="line">                    <span class="keyword">return</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            handleMessage(msg);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;首先检查 Message 的 callback 是否为 null，不为 null 就通过 handleCallback 来处理消息。Message 的 callback 是一个 Runnable 对象，实际上就是 Handler 的 post 方法所传递的 Runnable 参数。</p>
<p>&#160; &#160; &#160; &#160;然后在第5行进行判断，如果 mCallback 不为 null，则调用 mCallback 的 handleMessage() 方法来处理消息。Callback 是个接口，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback interface you can use when instantiating a Handler to avoid</span></span><br><span class="line"><span class="comment"> * having to implement your own subclass of Handler.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if no further handling is desired</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;通过 Callback 可以采用如下方式来创建 Handler 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler handler = <span class="keyword">new</span> Handler(callback);</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;那么 Callback 的意义是什么呢？源码里面的注释已经做了说明：可以用来创建一个 Handler 的实例但并不需要派生 Handler 的子类。在日常开发中，创建 Handler 最常见的方式就是派生一个 Handler 的子类并重写其 handleMessage 方法来处理具体的消息，而 Callback 给我们提供了另外一种使用 Handler 的方式，当我们不想派生子类时，就可以通过 Callback 来实现。</p>
<p>&#160; &#160; &#160; &#160;最后，调用 Handler 的 handleMessage() 方法，并将消息对象作为参数传递过去。handleMessage 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;可以看到这是一个空方法，因为消息的最终回调是由我们控制的，我们在创建 handler 的时候都是复写 handleMessage 方法，然后根据 msg.what 进行消息处理。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;  </span><br><span class="line">      <span class="keyword">case</span> value:  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">      <span class="keyword">default</span>:  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;Handler 处理消息的过程可以归纳为如下流程图：</p>
<p><img src="https://github.com/wy521angel/MarkdowmPhotos/blob/master/IT/Android/%E7%BA%BF%E7%A8%8B/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/Handler%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true" alt="Handler处理消息流程图"></p>
<h1 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h1><p>&#160; &#160; &#160; &#160;一个最标准的异步消息处理线程的写法应该是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">public</span> Handler mHandler;  </span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          Looper.prepare();  </span><br><span class="line"></span><br><span class="line">          mHandler = <span class="keyword">new</span> Handler() &#123;  </span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;  </span><br><span class="line">                  <span class="comment">// process incoming messages here  </span></span><br><span class="line">              &#125;  </span><br><span class="line">          &#125;;  </span><br><span class="line"></span><br><span class="line">          Looper.loop();  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;到此，这个流程已经解释完毕，总结一下：</p>
<ol>
<li>首先 Looper.prepare() 在本线程中保存一个 Looper 实例，然后该实例中保存一个 MessageQueue 对象；因为 Looper.prepare() 在一个线程中只能调用一次，所以 MessageQueue 在一个线程中只会存在一个。  </li>
<li>Looper.loop() 会让当前线程进入一个无限循环，不断从 MessageQueue 的实例中读取消息，然后回调 msg.target.dispatchMessage(msg) 方法。  </li>
<li>Handler 的构造方法，会首先得到当前线程中保存的 Looper 实例，进而与 Looper 实例中的 MessageQueue 相关联。  </li>
<li>Handler 的 sendMessage 方法，会给 msg 的 target 赋值为 handler 自身，然后加入 MessageQueue 中。  </li>
<li>在构造 Handler 实例时，我们会重写 handleMessage 方法，也就是 msg.target.dispatchMessage(msg) 最终调用的方法。</li>
</ol>
<p>&#160; &#160; &#160; &#160;整个异步消息处理流程的示意图如下两张图所示：</p>
<p><img src="https://raw.githubusercontent.com/wy521angel/MarkdowmPhotos/64f6f50d6d67050100760686fe5c0ddcfbf830c7/IT/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="异步消息处理流程的示意图"></p>
<p><img src="https://raw.githubusercontent.com/wy521angel/MarkdowmPhotos/4f889a4c7963a529339bb0e9276f1ae81be2172e/IT/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/Looper%20%2C%20Handler%20%2C%20Message%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png" alt="Looper , Handler , Message三者关系"></p>
<h1 id="在子线程中进行-UI-操作的其它方法"><a href="#在子线程中进行-UI-操作的其它方法" class="headerlink" title="在子线程中进行 UI 操作的其它方法"></a>在子线程中进行 UI 操作的其它方法</h1><p>&#160; &#160; &#160; &#160;除了发送消息之外，我们还有以下几种方法可以在子线程中进行UI操作：</p>
<ol>
<li>Handler 的 post() 方法</li>
<li>View 的 post() 方法</li>
<li>Activity 的 runOnUiThread() 方法</li>
</ol>
<p>&#160; &#160; &#160; &#160;先来看下 Handler 中的 post() 方法，有时候为了方便，我们会直接写如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mHandler.post(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Log.e(<span class="string">"TAG"</span>, Thread.currentThread().getName());</span><br><span class="line">    mTxt.setText(<span class="string">"yoxi"</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;然后 run 方法中可以写更新 UI 的代码，其实这个 Runnable 并没有创建线程，而是发送了一条消息，下面看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;这里调用 sendMessageDelayed() 方法去发送一条消息，并且还使用了 getPostMessage() 方法将 Runnable 对象转换成了一条消息，看下这个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;  </span><br><span class="line">    Message m = Message.obtain();  </span><br><span class="line">    m.callback = r;  </span><br><span class="line">    <span class="keyword">return</span> m;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;可以看到，在 getPostMessage 中，得到了一个 Message 对象，然后将我们创建的 Runable 对象作为 callback 属性，赋值给了此 message。</p>
<p>&#160; &#160; &#160; &#160;另外，产生一个 Message 对象，可以 new，也可以使用 Message.obtain() 方法；两者都可以，但是更建议使用 obtain 方法，因为 Message 内部维护了一个 Message 池用于 Message 的复用，避免使用 new 重新分配内存。</p>
<p>&#160; &#160; &#160; &#160; Handler 的 post() 方法最终和 handler.sendMessage 一样，调用了 sendMessageAtTime，然后调用了 enqueueMessage 方法，给 msg.target 赋值为 handler，最终加入 MessagQueue。</p>
<p>&#160; &#160; &#160; &#160;getPostMessage 方法中将消息的 callback 字段的值指定为传入的 Runnable 对象，在 Handler 的 dispatchMessage() 方法中有做一个检查，如果 Message 的 callback 等于 null 才会去调用 handleMessage() 方法，否则就调用 handleCallback() 方法，也就是我们的Runnable对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;  </span><br><span class="line">           handleCallback(msg);  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">           <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;  </span><br><span class="line">               <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;  </span><br><span class="line">                   <span class="keyword">return</span>;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           handleMessage(msg);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;看下 handleCallback() 方法中的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;  </span><br><span class="line">    message.callback.run();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;就是直接调用了一开始传入的 Runnable 对象的 run() 方法。因此在子线程中通过 Handler 的 post() 方法进行 UI 操作完整写法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler handler;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">        setContentView(R.layout.activity_main);  </span><br><span class="line">        handler = <span class="keyword">new</span> Handler();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                handler.post(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                        <span class="comment">// 在这里进行UI操作  </span></span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;虽然写法上相差很多，但是原理是完全一样的，我们在 Runnable 对象的 run() 方法里更新 UI，效果完全等同于在 handleMessage() 方法中更新 UI。</p>
<p>&#160; &#160; &#160; &#160;然后再来看一下 View 中的 post() 方法，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;  </span><br><span class="line">    Handler handler;  </span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        handler = mAttachInfo.mHandler;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        ViewRoot.getRunQueue().post(action);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> handler.post(action);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;原来就是调用了 Handler 中的 post() 方法。</p>
<p>&#160; &#160; &#160; &#160;最后再来看一下 Activity 中的 runOnUiThread() 方法，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;  </span><br><span class="line">        mHandler.post(action);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        action.run();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;如果当前的线程不等于 UI 线程(主线程)，就去调用 Handler的 post() 方法，否则就直接调用 Runnable 对象的 run() 方法。</p>
<p>&#160; &#160; &#160; &#160;通过以上所有源码的分析，我们已经发现了，不管是使用哪种方法在子线程中更新 UI，其实背后的原理都是相同的，必须都要借助异步消息处理的机制来实现。</p>
<blockquote>
<p>参考资料：<br>guolin <a href="https://blog.csdn.net/guolin_blog/article/details/9991569" target="_blank" rel="noopener">Android异步消息处理机制完全解析，带你从源码的角度彻底理解</a><br>鸿洋_ <a href="https://blog.csdn.net/lmj623565791/article/details/38377229" target="_blank" rel="noopener">Android 异步消息处理机制 让你深入理解 Looper、Handler、Message三者关系</a><br>《Android 开发艺术探索》任玉刚 第10章 Android的消息机制</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          
            <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># 源码分析</a>
          
            <a href="/tags/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF/" rel="tag"># 异步消息</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/10/IT/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E7%A1%AE%E4%BF%9D%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20%EF%BC%88%E4%B8%89%EF%BC%89/" rel="next" title="确保对象的唯一性——单例模式（三）">
                <i class="fa fa-chevron-left"></i> 确保对象的唯一性——单例模式（三）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/12/IT/Android/Service%E7%9B%B8%E5%85%B3/Service%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" rel="prev" title="Service使用详解">
                Service使用详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMDEwMS82NjU2"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/myavatar.jpg"
               alt="wy521angel" />
          <p class="site-author-name" itemprop="name">wy521angel</p>
           
              <p class="site-description motion-element" itemprop="description">存放一些IT技术积累</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">138</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">48</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">53</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/lmj623565791" title="Hongyang的博客" target="_blank">Hongyang的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/guolin_blog" title="郭霖的博客" target="_blank">郭霖的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/eclipsexys" title="eclipse_xu的博客" target="_blank">eclipse_xu的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/lovelion?viewmode=list" title="刘伟的博客" target="_blank">刘伟的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://philipdroid.github.io" title="philipdroid的博客" target="_blank">philipdroid的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jcodecraeer.com" title="泡在网上的日子" target="_blank">泡在网上的日子</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://juejin.im/timeline" title="掘金" target="_blank">掘金</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.infoq.com/cn" title="InfoQ" target="_blank">InfoQ</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.uisdc.com" title="优设" target="_blank">优设</a>
                </li>
              
            </ul>
          </div>
        

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=34341358&auto=0&height=66"></iframe>
        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Looper的两个重要方法"><span class="nav-number">2.</span> <span class="nav-text">Looper的两个重要方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Looper-prepare"><span class="nav-number">2.1.</span> <span class="nav-text">Looper.prepare()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Looper-loop"><span class="nav-number">2.2.</span> <span class="nav-text">Looper.loop()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Handler-消息发送与-MessageQueue"><span class="nav-number">3.</span> <span class="nav-text">Handler 消息发送与 MessageQueue</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#流程总结"><span class="nav-number">4.</span> <span class="nav-text">流程总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在子线程中进行-UI-操作的其它方法"><span class="nav-number">5.</span> <span class="nav-text">在子线程中进行 UI 操作的其它方法</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wy521angel</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("xVeur9szsyg7AkKwseQcBlqr-MdYXbMMI", "UEl3HMLcU0j2xYsHkUlJGVS8");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

  
  <a href="https://github.com/wy521angel" target="_blank" rel="noopener"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>
  
  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
